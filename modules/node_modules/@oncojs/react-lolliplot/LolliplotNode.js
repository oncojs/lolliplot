// @flow

import React from 'react'
import invariant from 'invariant'
import ReactFauxDOM from 'react-faux-dom'
import attrs from './attrs'
import { dim, halfPixel } from './spatial'
import setupFilters from './filters'
import setupMinimap from './minimap'
import setupProteins from './proteins'
import { setupMutations } from './mutations'
import setupTicks from './ticks'
import theme from './theme'
import groupByType from './groupByType'
import uuid from './uuid'

/*----------------------------------------------------------------------------*/

type TProteinLolliplotArgs = {|
  d3: Object,
  data: Object,
  height: number,
  width: number,
  domainWidth: number,
  mutationId?: string,
  yAxisOffset?: number,
  xAxisOffset?: number,
  proteinHeight?: number,
  numXTicks?: number,
  numYTicks?: number,
  proteinDb?: string,
  onMutationClick?: Function,
  onMutationMouseover?: Function,
  onMutationMouseout?: Function,
  onProteinClick?: Function,
  onProteinMouseover?: Function,
  onProteinMouseout?: Function,
  onInit?: Function,
  animating: boolean,
  min: number,
  max: number,
  dragging: boolean,
  draggingMinimap: boolean,
  sliding: boolean,
  _update: Function,
  offsetX: number,
  zoomStart: number,
  targetMin: number,
  targetMax: number,
  proteinMouseover: boolean | string,
  update: Function,
  slideStartMin: number,
  slideStartMax: number,
  slideStart: number,
|}
type TProteinLolliplot = (args: TProteinLolliplotArgs) => React.Element<*>
let proteinLolliplot: TProteinLolliplot = ({
  d3,
  data,
  height,
  width,
  domainWidth = 500,
  mutationId = ``,
  yAxisOffset = 45,
  xAxisOffset = 200,
  proteinHeight = 40,
  numXTicks = 12,
  numYTicks = 15,
  proteinDb = `pfam`,
  onMutationClick = () => {},
  onMutationMouseover = () => {},
  onMutationMouseout = () => {},
  onProteinClick = () => {},
  onProteinMouseover = () => {},
  onProteinMouseout = () => {},
  animating,
  min,
  max,
  dragging,
  draggingMinimap,
  sliding,
  _update,
  update,
  offsetX,
  zoomStart,
  proteinMouseover,
  slideStartMin,
  slideStartMax,
  slideStart,
} = {}) => {

  invariant(d3, `You must pass in the d3 library, either v3 || v4`)

  d3.selection.prototype.attrs = attrs
  d3.scaleOrdinal = d3.scaleOrdinal || d3.scale.ordinal
  d3.scaleLinear = d3.scaleLinear || d3.scale.linear

  // Similar to a React target element
  let root = ReactFauxDOM.createElement(`div`)

  invariant(root, `Must provide an element or selector!`)

  width = width || root.clientWidth
  height = height || root.clientHeight

  let uniqueSelector = uuid()
  let xAxisLength = width - yAxisOffset
  let scale = xAxisLength / domainWidth

  let consequences = groupByType(`consequence`, data.mutations)

  let colorScale = d3.schemeCategory20
    ? d3.scaleOrdinal(d3.schemeCategory20).domain(d3.range(20))
    : d3.scale.category20().domain(d3.range(20))

  let consequenceColors = Object.keys(consequences).reduce((acc, type, i) => ({
    ...acc,
    [type]: colorScale(i * 3),
  }), {})

  let visibleMutations = data.mutations.filter(d =>
    d.x > min && d.x < max
  )

  let maxDonors = Math.max(...visibleMutations.map(x => x.donors))

  let highestValue = Math.max(10, maxDonors)

  let scaleLinearY = d3.scaleLinear()
    .domain([0, highestValue])
    .range([height - xAxisOffset, 15])

  let updateTargetChartZoom = ({ zoomX, zoomWidth, offsetX, difference }) => {
    let draggingLeft = difference < 0

    let scale = d3.scaleLinear()
      .domain([0, xAxisLength])
      .range([min, max])

    let targetMin = Math.max(
      0,
      (draggingLeft ? scale(offsetX - yAxisOffset) : scale(zoomX - yAxisOffset))
    )

    let targetMax = Math.min(
      domainWidth,
      (draggingLeft ? scale(offsetX + zoomWidth - yAxisOffset) : scale(offsetX - yAxisOffset))
    )

    return [targetMin, targetMax]
  }

  let updateTargetMinimapZoom = ({ zoomX, zoomWidth, offsetX, difference }) => {
    let draggingLeft = difference < 0

    let targetMin = Math.max(
      0,
      (draggingLeft ? (offsetX - yAxisOffset) / scale : (zoomX - yAxisOffset) / scale)
    )

    let targetMax = Math.min(
      domainWidth,
      (draggingLeft ? (offsetX - yAxisOffset + zoomWidth) / scale : (offsetX - yAxisOffset) / scale)
    )

    return [targetMin, targetMax]
  }

  // Main Chart

  let d3Root = d3.select(root).style(`position`, `relative`)

  let svg = d3Root
    .append(`svg`)
    .attrs({
      class: `chart`,
      ...dim(width, height),
    })
    .on(`mousemove`, () => {
      if (sliding) {
        update({
          min: Math.max(0, slideStartMin + Math.round((d3.event.offsetX - slideStart) / scale)),
          max: Math.min(
            domainWidth,
            slideStartMax + Math.round((d3.event.offsetX - slideStart) / scale)
          ),
        })
      }
    })
    .on(`mouseup`, () => {
      if (sliding) {
        _update({ sliding: false })
      }

      if (dragging || draggingMinimap) {

        let difference = offsetX - zoomStart

        // do not zoom if insignificant dragging distance
        if (Math.abs(difference) < 5) {
          _update({ dragging: false, draggingMinimap: false })
          return
        }

        if (dragging) {
          let [targetMin, targetMax] = updateTargetChartZoom({
            zoomX: difference < 0 ? offsetX : zoomStart,
            zoomWidth: Math.abs(difference),
            offsetX,
            difference,
          })

          update({
            min: targetMin,
            max: targetMax,
          })
        }

        if (draggingMinimap) {
          let [targetMin, targetMax] = updateTargetMinimapZoom({
            zoomX: difference < 0 ? offsetX : zoomStart,
            zoomWidth: Math.abs(difference),
            offsetX,
            difference,
          })

          update({
            min: targetMin,
            max: targetMax,
          })
        }

        _update({
          dragging: false,
          draggingMinimap: false,
        })
      }
    })

  let defs = svg.append(`defs`)

  setupFilters(defs)

  // Chart clipPath

  defs
    .append(`clipPath`)
    .attr(`id`, `${uniqueSelector}-chart-clip`)
    .append(`rect`)
    .attrs({
      x: yAxisOffset,
      y: 0,
      ...dim(xAxisLength, height - xAxisOffset + proteinHeight),
    })

  // Chart zoom area

  let chart = d3Root.select(`.chart`)

  chart
    .append(`rect`)
    .attrs({
      class: `chart-zoom-area`,
      x: yAxisOffset,
      y: halfPixel,
      width: xAxisLength,
      height: height - xAxisOffset + proteinHeight - halfPixel,
      fill: `white`,
      stroke: `rgb(181, 181, 181)`,
      'stroke-width': 1,
    })
    .on(`mousedown`, () => {
      _update({
        dragging: true,
        zoomStart: d3.event.offsetX,
        offsetX: d3.event.offsetX,
      })
    })
    .on(`mousemove`, () => {
      _update({
        offsetX: d3.event.offsetX,
      })
    })

  // yAxis

  svg
    .append(`g`)
    .append(`line`)
    .attrs({
      class: `yAxis`,
      x1: yAxisOffset,
      y1: 0,
      x2: yAxisOffset,
      y2: height - xAxisOffset + proteinHeight,
      stroke: theme.black,
    })

  // yAxis label

  chart
    .append(`text`)
    .text(`# of Cases`)
    .attrs({
      x: 5,
      y: (height - xAxisOffset) / 2,
      'font-size': `11px`,
      transform: `rotate(270, 10, 124)`,
    })

  // xAxis

  svg
    .append(`g`)
    .append(`line`)
    .attrs({
      class: `xAxis`,
      x1: yAxisOffset,
      y1: height - xAxisOffset,
      x2: width,
      y2: height - xAxisOffset,
      stroke: theme.black,
    })

  // Vertical line on the right of the protein bar

  svg
    .append(`g`)
    .append(`line`)
    .attrs({
      class: `yAxisRight`,
      x1: width,
      y1: height - xAxisOffset,
      x2: width,
      y2: height - xAxisOffset + proteinHeight,
      stroke: theme.black,
    })

  // Horizontal line under protein bar

  svg
    .append(`g`)
    .append(`line`)
    .attrs({
      class: `xAxisBottom`,
      x1: yAxisOffset,
      y1: height - xAxisOffset + proteinHeight + halfPixel,
      x2: width,
      y2: height - xAxisOffset + proteinHeight + halfPixel,
      stroke: theme.black,
    })

  setupMinimap({
    svg,
    width,
    height,
    yAxisOffset,
    xAxisOffset,
    xAxisLength,
    proteinHeight,
    domainWidth,
    uniqueSelector,
    min,
    max,
    scale,
    d3,
    _update,
  })

  chart
    .append(`text`)
    .text(proteinDb)
    .attrs({
      x: 5,
      y: height - xAxisOffset + 25,
      'font-size': `11px`,
    })

  if (dragging) {
    let difference = offsetX - zoomStart

    svg
      .append(`g`)
      .append(`rect`)
      .attrs({
        'clip-path': `url(#${uniqueSelector}-clip)`,
        x: difference < 0 ? offsetX : zoomStart,
        y: 0,
        width: Math.abs(difference),
        height: height - xAxisOffset,
        fill: `rgba(214, 214, 214, 0.51)`,
        cursor: `text`,
        'pointer-events': `none`,
      })
  }

  if (draggingMinimap) {
    let difference = offsetX - zoomStart

    svg
      .append(`g`)
      .append(`rect`)
      .attrs({
        'clip-path': `url(#${uniqueSelector}-clip)`,
        x: difference < 0 ? offsetX : zoomStart,
        y: height - xAxisOffset + proteinHeight + 20,
        width: Math.abs(difference),
        height: 50,
        fill: `rgba(83, 215, 88, 0.51)`,
        cursor: `text`,
        'pointer-events': `none`,
      })
  }

  setupMutations({
    d3,
    chart,
    consequenceColors,
    scaleLinearY,
    onMutationClick,
    onMutationMouseover,
    onMutationMouseout,
    mutationId,
    data,
    yAxisOffset,
    xAxisOffset,
    height,
    proteinHeight,
    scale,
    maxDonors,
    animating,
    uniqueSelector,
    min,
    max,
    width,
  })

  let minimapWidth = Math.max(1, ((max - min) * scale) - 1)

  svg
    .append(`g`)
    .append(`rect`)
    .attrs({
      class: `minimap-slide-target`,
      x: (min * scale) + yAxisOffset + halfPixel + minimapWidth - 20,
      y: height - xAxisOffset + proteinHeight + 25,
      ...dim(15, 15),
      fill: `rgb(255, 255, 255)`,
      stroke: `rgb(57, 57, 57)`,
      cursor: `move`,
    })
    .on(`mousedown`, () => {
      _update({
        sliding: true,
        slideStart: d3.event.offsetX,
        slideStartMin: min,
        slideStartMax: max,
      })
    })

  svg
    .append(`text`)
    .text(`⟺`)
    .attrs({
      class: `minimap-slide-target-arrow`,
      x: (min * scale) + yAxisOffset + halfPixel + minimapWidth - 19,
      y: height - xAxisOffset + proteinHeight + 36,
      'font-size': `11px`,
      'pointer-events': `none`,
    })

  setupProteins({
    d3,
    chart,
    defs,
    onProteinClick,
    onProteinMouseover,
    onProteinMouseout,
    data,
    scale,
    yAxisOffset,
    xAxisOffset,
    proteinHeight,
    height,
    uniqueSelector,
    min,
    max,
    width,
    domainWidth,
    proteinMouseover,
  })

  setupTicks({
    d3Root,
    svg,
    numYTicks,
    numXTicks,
    maxDonors,
    scaleLinearY,
    xAxisOffset,
    yAxisOffset,
    domainWidth,
    scale,
    height,
    min,
    max,
    highestValue,
  })

  return root.toReact()

}

/*----------------------------------------------------------------------------*/

export default proteinLolliplot
