// @flow

import * as d3 from 'd3'
import _ from 'lodash'
import groupByType from './groupByType'
import { updateMutations } from './mutations'
import theme from './theme'
import { animateScaleY } from './animator'

// TODO: place in theme?
let impactsColors = {
  HIGH: `rgb(221, 60, 60)`,
  MODERATE: `rgb(132, 168, 56)`,
  default: `rgb(135, 145, 150)`,
}

type TRenderCheckboxItemArgs = {
  colors: Object,
  type: String,
  dataSource: Object,
}
type TRenderCheckboxItem =  (args: TRenderCheckboxItemArgs) => string
function renderCheckboxItem({
  colors,
  type,
  dataSource,
}) : TRenderCheckboxItem {
  return `
    <span class="toggle-checkbox" data-checked="true" style="color: ${colors[type] || colors.default}; text-align: center; border: 2px solid ${colors[type] || colors.default}; display: inline-block; width: 23px; cursor: pointer; margin-right: 6px;">✓</span>
    <span>${_.startCase(type)}:</span>
    <span style="margin: 0 10px 0 auto;" class="counts">
      <b>${dataSource[type].length}</b> / <b>${dataSource[type].length}</b>
    </span>
  `
}

type TSetupStatsArgs = {
  consequenceColors: Object,
  data: Object,
  store: Object,
  selector: string,
  hideStats: bool,
  statsBoxWidth: number,
  width: number,
  selectedMutationClass: string,
  consequences: Object,
  impacts: Object,
  mutationChartLines: Object,
  mutationChartCircles: Object,
  height: number,
  xAxisOffset: number,
}
type TSetupStats = (args: TSetupStatsArgs) => Object
let setupStats: TSetupStats = ({
  consequenceColors,
  data,
  store,
  selector,
  hideStats,
  statsBoxWidth,
  width,
  selectedMutationClass,
  consequences,
  impacts,
  mutationChartLines,
  mutationChartCircles,
  height,
  xAxisOffset,
}) => {
  // Stats Bar

  let stats = d3.select(selector)
    .append(`div`)
    .attr(`id`, `mutation-stats`)
    .style(`display`, hideStats ? `none` : `block`)
    .style(`background-color`, `white`)
    .style(`border`, `1px solid rgb(186, 186, 186)`)
    .style(`padding`, `13px`)
    .style(`width`, `${statsBoxWidth}px`)

  stats
    .style(`position`, `absolute`)
    .style(`top`, `0px`)
    .style(`left`, width - statsBoxWidth + 35 + `px`)
    .style(`line-height`, `20px`)
    .append(`div`)
    .html(`Viewing <b>${data.mutations.length}</b> / <b>${data.mutations.length}</b> Mutations`)
    .attr(`class`, `mutation-count`)
    .style(`font-size`, `16px`)

  stats
    .append(`select`)
    .html(`
      <option>Consequence</option>
      <option>Impact</option>
    `)
    .style(`margin-top`, `6px`)
    .on(`change`, () => {
      d3.selectAll(`[id^=class]`).style(`display`, `none`)
      d3.select(`#class-${d3.event.target.value}`).style(`display`, `block`)

      d3.selectAll(`[class^=mutation-circle]`)
        .attr(`fill`, d => d3.event.target.value === `Consequence`
          ? consequenceColors[d.consequence]
          : impactsColors[d.impact] || impactsColors.default
        )
    })

  stats
    .append(`div`)
    .text(`Click to filter mutations`)
    .style(`margin-top`, `6px`)
    .style(`font-size`, `11px`)
    .style(`color`, theme.black)

  let consequencesContainer = stats
    .append(`span`)
    .text(`Consequence:`)
    .attr(`id`, `class-Consequence`)
    .style(`display`, selectedMutationClass === `Consequence` ? `block` : `none`)
    .style(`margin-top`, `6px`)
    .style(`font-size`, `14px`)

 let consequencesCheckboxContainers = _.mapValues(consequences, (item, type) => (
    consequencesContainer
      .append(`div`)
      .html(renderCheckboxItem({
        colors: consequenceColors,
        type,
        dataSource: consequences,
      }))
      .style(`margin-top`, `6px`)
      .style(`font-size`, `14px`)
      .style(`display`, `flex`)
      .style(`align-items`, `center`)
      .on(`click`, function () {
        // Bail if not the checkbox above
        if (!Array.from(d3.event.target.classList).includes(`toggle-checkbox`)) return

        d3.event.target.dataset.checked = d3.event.target.dataset.checked === `true`
          ? `false`
          : `true`

        let checked = d3.event.target.dataset.checked === `true`
        let { consequenceFilters } = store.getState()

        d3.select(this).select(`.toggle-checkbox`)
          .html(checked ? `✓` : `&nbsp;`)

        store.update({ consequenceFilters: checked
          ? consequenceFilters.filter(d => d !== type)
          : [...consequenceFilters, type],
        })

        updateStats({
          store,
          data,
          consequences,
          impacts,
          consequenceColors,
          mutationChartLines,
          mutationChartCircles,
          height,
          xAxisOffset,
          impactsCheckboxContainers,
          consequencesCheckboxContainers,
        })

        updateMutations({ checked, mutationClass: `consequence`, type, data })
      })
 ))

  let impactsContainer = stats
    .append(`span`)
    .text(`Impact:`)
    .attr(`id`, `class-Impact`)
    .style(`display`, selectedMutationClass === `Impact` ? `block` : `none`)
    .style(`margin-top`, `6px`)
    .style(`font-size`, `14px`)

  let impactsCheckboxContainers = _.mapValues(impacts, (item, type) => (
    impactsContainer
      .append(`div`)
      .html(renderCheckboxItem({
        colors: impactsColors,
        type,
        dataSource: impacts,
      }))
      .style(`margin-top`, `6px`)
      .style(`font-size`, `14px`)
      .style(`display`, `flex`)
      .style(`align-items`, `center`)
      .on(`click`, function () {
        // Bail if not the checkbox above
        if (!Array.from(d3.event.target.classList).includes(`toggle-checkbox`)) return

        d3.event.target.dataset.checked = d3.event.target.dataset.checked === `true`
          ? `false`
          : `true`

        let checked = d3.event.target.dataset.checked === `true`
        let { impactFilters } = store.getState()

        d3.select(this).select(`.toggle-checkbox`)
          .html(checked ? `✓` : `&nbsp;`)

        store.update({ impactFilters: checked
          ? impactFilters.filter(d => d !== type)
          : [...impactFilters, type],
        })

        updateStats({
          store,
          data,
          consequences,
          impacts,
          consequenceColors,
          mutationChartLines,
          mutationChartCircles,
          height,
          xAxisOffset,
          impactsCheckboxContainers,
          consequencesCheckboxContainers,
        })

        updateMutations({ checked, mutationClass: `impact`, type, data })
      })
  ))

  return {
    consequencesCheckboxContainers,
    impactsCheckboxContainers,
  }
}

type TUpdateStatsArgs = {
  store: Object,
  data: Object,
  consequences: Object,
  impacts: Object,
  consequenceColors: Object,
  mutationChartLines: Object,
  mutationChartCircles: Object,
  height: number,
  xAxisOffset: number,
}
type TUpdateStats = (args: TUpdateStatsArgs) => void
let updateStats: TUpdateStats = ({
  store,
  data,
  consequences,
  impacts,
  consequenceColors,
  mutationChartLines,
  mutationChartCircles,
  height,
  xAxisOffset,
  impactsCheckboxContainers,
  consequencesCheckboxContainers,
}) => {
  let { min, max, consequenceFilters, impactFilters, animating } = store.getState()

  let visibleMutations = data.mutations.filter(d =>
    (d.x > min && d.x < max) &&
    !consequenceFilters.includes(d.consequence) &&
    !impactFilters.includes(d.impact)
  )

  let visibleMutationCounts = {
    impacts: _.countBy(visibleMutations, `impact`),
    consequences: _.countBy(visibleMutations, `consequence`),
  }
  _.forEach(consequencesCheckboxContainers, (container, type) => {
    container.select(`.counts`)
        .html(`<b>${visibleMutationCounts.consequences[type] || 0}</b> / <b>${consequences[type].length}</b>`)
  })
  _.forEach(impactsCheckboxContainers, (container, type) => {
    container.select(`.counts`)
        .html(`<b>${visibleMutationCounts.impacts[type] || 0}</b> / <b>${impacts[type].length}</b>`)
  })

  d3.select(`.mutation-count`)
    .html(`Viewing <b>${visibleMutations.length}</b> / <b>${data.mutations.length}</b> Mutations`)

  if (!animating) {
    animateScaleY({
      data,
      consequenceFilters,
      impactFilters,
      min,
      max,
      mutationChartLines,
      mutationChartCircles,
      height,
      xAxisOffset,
      visibleMutations,
    })
  }
}

/*----------------------------------------------------------------------------*/

export {
  setupStats,
  updateStats,
}
