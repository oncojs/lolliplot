// @flow

import startCase from 'lodash.startcase'
import countBy from 'lodash.countby'
import { updateMutations } from './mutations'
import theme from './theme'
import { animateScaleY } from './animator'

// TODO: place in theme?
let impactsColors = {
  HIGH: `rgb(221, 60, 60)`,
  MODERATE: `rgb(132, 168, 56)`,
  default: `rgb(135, 145, 150)`,
}

type TRenderCheckboxItemArgs = {
  colors: Object,
  type: string,
  dataSource: Object,
}
type TRenderCheckboxItem = (args: TRenderCheckboxItemArgs) => string
let renderCheckboxItem: TRenderCheckboxItem = ({
  colors,
  type,
  dataSource,
}) => `
  <span
    class="toggle-checkbox"
    data-checked="true"
    style="color: ${colors[type] || colors.default};
    text-align: center;
    border: 2px solid ${colors[type] || colors.default};
    display: inline-block;
    width: 23px;
    cursor: pointer;
    margin-right: 6px;"
  >
    ✓
  </span>
  <span>${startCase(type)}:</span>
  <span style="margin: 0 10px 0 auto;" class="counts">
    <b>${dataSource[type].length}</b> / <b>${dataSource[type].length}</b>
  </span>
`

type TSetupStatsArgs = {
  d3: Object,
  d3Root: Object,
  consequenceColors: Object,
  data: Object,
  store: Object,
  hideStats: bool,
  statsBoxWidth: number,
  width: number,
  selectedMutationClass: string,
  consequences: Object,
  impacts: Object,
  mutationChartLines: Object,
  mutationChartCircles: Object,
  height: number,
  xAxisOffset: number,
  yTicks: Object,
  yTicksLine: Object,
}
type TSetupStats = (args: TSetupStatsArgs) => Object
let setupStats: TSetupStats = ({
  d3,
  d3Root,
  consequenceColors,
  data,
  store,
  hideStats,
  statsBoxWidth,
  width,
  selectedMutationClass,
  consequences,
  impacts,
  mutationChartLines,
  mutationChartCircles,
  height,
  xAxisOffset,
  yTicks,
  yTicksLine,
}) => {
  // Stats Bar

  let stats = d3Root
    .append(`div`)
    .attr(`id`, `mutation-stats`)
    .style(`display`, hideStats ? `none` : `block`)
    .style(`background-color`, `white`)
    .style(`border`, `1px solid rgb(186, 186, 186)`)
    .style(`padding`, `13px`)
    .style(`width`, `${statsBoxWidth}px`)

  let mutationCount = stats
    .style(`position`, `absolute`)
    .style(`top`, `0px`)
    .style(`left`, width - statsBoxWidth + 35 + `px`)
    .style(`line-height`, `20px`)
    .append(`div`)
    .html(`Viewing <b>${data.mutations.length}</b> / <b>${data.mutations.length}</b> Mutations`)
    .attr(`class`, `mutation-count`)
    .style(`font-size`, `16px`)

  stats
    .append(`select`)
    .html(`
      <option>Consequence</option>
      <option>Impact</option>
    `)
    .style(`margin-top`, `6px`)
    .on(`change`, () => {
      d3Root.selectAll(`[id^=class]`).style(`display`, `none`)
      d3Root.select(`#class-${d3.event.target.value}`).style(`display`, `block`)

      d3Root.selectAll(`[class^=mutation-circle]`)
        .attr(`fill`, d => d3.event.target.value === `Consequence`
          ? consequenceColors[d.consequence]
          : impactsColors[d.impact] || impactsColors.default
        )
    })

  stats
    .append(`div`)
    .text(`Click to filter mutations`)
    .style(`margin-top`, `6px`)
    .style(`font-size`, `11px`)
    .style(`color`, theme.black)

  let consequencesContainer = stats
    .append(`span`)
    .text(`Consequence:`)
    .attr(`id`, `class-Consequence`)
    .style(`display`, selectedMutationClass === `Consequence` ? `block` : `none`)
    .style(`margin-top`, `6px`)
    .style(`font-size`, `14px`)

  let consequencesCheckboxContainers = Object.keys(consequences).reduce((acc, type) => ({
    ...acc,
    [type]: consequencesContainer
      .append(`div`)
      .html(renderCheckboxItem({
        colors: consequenceColors,
        type,
        dataSource: consequences,
      }))
      .style(`margin-top`, `6px`)
      .style(`font-size`, `14px`)
      .style(`display`, `flex`)
      .style(`align-items`, `center`)
      .on(`click`, function () {
        d3.event.target.dataset.checked = d3.event.target.dataset.checked === `true`
          ? `false`
          : `true`

        let checked = d3.event.target.dataset.checked === `true`
        let { consequenceFilters } = store.getState()

        d3.select(this).select(`.toggle-checkbox`)
          .html(checked ? `✓` : `&nbsp;`)

        store.update({ consequenceFilters: checked
          ? consequenceFilters.filter(d => d !== type)
          : [...consequenceFilters, type],
        })

        updateStats({
          d3,
          d3Root,
          store,
          data,
          consequences,
          impacts,
          consequenceColors,
          mutationChartLines,
          mutationChartCircles,
          height,
          xAxisOffset,
          consequencesCheckboxContainers,
          impactsCheckboxContainers,
          mutationCount,
          yTicks,
          yTicksLine,
        })

        updateMutations({ d3Root, checked, mutationClass: `consequence`, type, data })
      }),
  }), {})

  let impactsContainer = stats
    .append(`span`)
    .text(`Impact:`)
    .attr(`id`, `class-Impact`)
    .style(`display`, selectedMutationClass === `Impact` ? `block` : `none`)
    .style(`margin-top`, `6px`)
    .style(`font-size`, `14px`)

  let impactsCheckboxContainers = Object.keys(impacts).reduce((acc, type) => ({
    ...acc,
    [type]: impactsContainer
      .append(`div`)
      .html(renderCheckboxItem({
        colors: impactsColors,
        type,
        dataSource: impacts,
      }))
      .style(`margin-top`, `6px`)
      .style(`font-size`, `14px`)
      .style(`display`, `flex`)
      .style(`align-items`, `center`)
      .on(`click`, function () {
        d3.event.target.dataset.checked = d3.event.target.dataset.checked === `true`
          ? `false`
          : `true`

        let checked = d3.event.target.dataset.checked === `true`
        let { impactFilters } = store.getState()

        d3.select(this).select(`.toggle-checkbox`)
          .html(checked ? `✓` : `&nbsp;`)

        store.update({ impactFilters: checked
          ? impactFilters.filter(d => d !== type)
          : [...impactFilters, type],
        })

        updateStats({
          d3,
          d3Root,
          store,
          data,
          consequences,
          impacts,
          consequenceColors,
          mutationChartLines,
          mutationChartCircles,
          height,
          xAxisOffset,
          consequencesCheckboxContainers,
          impactsCheckboxContainers,
          mutationCount,
          yTicks,
          yTicksLine,
        })

        updateMutations({ d3Root, checked, mutationClass: `impact`, type, data })
      }),
  }), {})

  return {
    stats,
    consequencesCheckboxContainers,
    impactsCheckboxContainers,
    mutationCount,
  }
}

type TUpdateStatsArgs = {
  d3: Object,
  d3Root: Object,
  store: Object,
  data: Object,
  consequences: Object,
  impacts: Object,
  consequenceColors: Object,
  mutationChartLines: Object,
  mutationChartCircles: Object,
  height: number,
  xAxisOffset: number,
  consequencesCheckboxContainers: Object,
  impactsCheckboxContainers: Object,
  mutationCount: Object,
  yTicks: Object,
  yTicksLine: Object,
}
type TUpdateStats = (args: TUpdateStatsArgs) => void
let updateStats: TUpdateStats = ({
  d3,
  d3Root,
  store,
  data,
  consequences,
  impacts,
  mutationChartLines,
  mutationChartCircles,
  height,
  xAxisOffset,
  consequencesCheckboxContainers,
  impactsCheckboxContainers,
  mutationCount,
  yTicks,
  yTicksLine,
}) => {
  let { min, max, consequenceFilters, impactFilters, animating } = store.getState()

  let visibleMutations = data.mutations.filter(d =>
    (d.x > min && d.x < max) &&
    !consequenceFilters.includes(d.consequence) &&
    !impactFilters.includes(d.impact)
  )

  let visibleMutationCounts = {
    impacts: countBy(visibleMutations, `impact`),
    consequences: countBy(visibleMutations, `consequence`),
  }

  Object.entries(consequencesCheckboxContainers).forEach(([type, container]) =>
    container.select(`.counts`)
      .html(`
        <b>${visibleMutationCounts.consequences[type] || 0}</b> / <b>${consequences[type].length}</b>`
      )
  )

  Object.entries(impactsCheckboxContainers).forEach(([type, container]) =>
    container.select(`.counts`)
      .html(`<b>${visibleMutationCounts.impacts[type] || 0}</b> / <b>${impacts[type].length}</b>`)
  )

  mutationCount
    .html(`Viewing <b>${visibleMutations.length}</b> / <b>${data.mutations.length}</b> Mutations`)

  if (!animating) {
    animateScaleY({
      d3,
      d3Root,
      data,
      consequenceFilters,
      impactFilters,
      min,
      max,
      mutationChartLines,
      mutationChartCircles,
      height,
      xAxisOffset,
      visibleMutations,
      yTicks,
      yTicksLine,
    })
  }
}

/*----------------------------------------------------------------------------*/

export {
  setupStats,
  updateStats,
}
