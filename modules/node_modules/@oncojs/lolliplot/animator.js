// @flow

import { shouldAnimationFinish, calculateNextCoordinate } from './animation'
import { halfPixel } from './spatial'
import { updateStats } from './stats'

type TAnimatorArgs = {
  d3: Object,
  d3Root: Object,
  store: Object,
  data: Object,
  yAxisOffset: number,
  xAxisOffset: number,
  statsBoxWidth: number,
  height: number,
  width: number,
  domainWidth: number,
  scale: number,
  numXTicks: number,
  mutationChartLines: Object,
  mutationChartCircles: Object,
  consequences: Object,
  impacts: Object,
  consequenceColors: Object,
  consequencesCheckboxContainers: Object,
  impactsCheckboxContainers: Object,
  proteinBars: Object,
  proteinClipPaths: Object,
  proteinNames: Object,
  xTicks: Object,
  yTicks: Object,
  yTicksLine: Object,
  minimapZoomArea: Object,
  minimapSlideTarget: Object,
  minimapSlideTargetArrow: Object,
  mutationCount: Object,
  animate: bool,
  hideStats: bool,
}
type TAnimator = (args: TAnimatorArgs) => Function
let animator: TAnimator = ({
  d3,
  d3Root,
  store,
  data,
  yAxisOffset,
  xAxisOffset,
  statsBoxWidth,
  height,
  width,
  domainWidth,
  scale,
  numXTicks,
  mutationChartLines,
  mutationChartCircles,
  consequences,
  impacts,
  consequenceColors,
  consequencesCheckboxContainers,
  impactsCheckboxContainers,
  proteinBars,
  proteinClipPaths,
  proteinNames,
  xTicks,
  yTicks,
  yTicksLine,
  minimapZoomArea,
  minimapSlideTarget,
  minimapSlideTargetArrow,
  mutationCount,
  animate,
  hideStats,
}) => {

  let totalAnimationIterations = animate ? 30 : 1

  let draw = () => {

    let {
      targetMin,
      targetMax,
      startMin,
      startMax,
      currentAnimationIteration,
      consequenceFilters,
      impactFilters,
    } = store.getState()

    let min = calculateNextCoordinate({
      start: startMin, target: targetMin, currentAnimationIteration, totalAnimationIterations,
    })

    let max = calculateNextCoordinate({
      start: startMax, target: targetMax, currentAnimationIteration, totalAnimationIterations,
    })

    let domain = max - min

    store.update({ min, max, domain, currentAnimationIteration: currentAnimationIteration + 1 })

    if (shouldAnimationFinish({ startMin, startMax, targetMin, targetMax, min, max })) {
      store.update({
        animating: false,
        startMin: min,
        startMax: max,
        currentAnimationIteration: 0,
      })
    }

    let scaleLinear = d3.scaleLinear()
      .domain([min, max])
      .range([yAxisOffset, width - statsBoxWidth])

    let widthZoomRatio = domainWidth / Math.max((max - min), 0.00001) // Do not divide by zero

    // Proteins

    proteinBars
      .attr(`x`, d => Math.max(yAxisOffset, scaleLinear(d.start)) + halfPixel)
      .attr(`width`, d => {
        let barWidth = (d.end - Math.max(d.start, min)) * widthZoomRatio * scale
        return Math.max(0, barWidth - 1)
      })

    proteinClipPaths
      .attr(`x`, d => Math.max(yAxisOffset, scaleLinear(d.start)) + halfPixel)
      .attr(`width`, d => {
        let barWidth = (d.end - Math.max(d.start, min)) * widthZoomRatio * scale
        return Math.max(0, barWidth - 1)
      })

    proteinNames
      .attr(`x`, d => {
        let barWidth = (d.end - Math.max(d.start, min)) * widthZoomRatio * scale
        let x = scaleLinear(d.start)
        return barWidth + yAxisOffset < yAxisOffset ? x : Math.max(yAxisOffset, x)
      })

    // Horizontal ticks
    let length = domain / numXTicks
    xTicks
      .text(i => Math.round((length * i) + min))

    // Minimap zoom area

    let minimapWidth = Math.max(1, ((max - min) * scale) - 1)

    minimapZoomArea
      .attr(`x`, (min * scale) + yAxisOffset + halfPixel)
      .attr(`width`, minimapWidth)

    minimapSlideTarget
      .attr(`x`, (min * scale) + yAxisOffset + halfPixel + minimapWidth - 20)

    minimapSlideTargetArrow
      .attr(`x`, (min * scale) + yAxisOffset + halfPixel + minimapWidth - 19)

    mutationChartLines
      .attr(`x1`, d => scaleLinear(d.x))
      .attr(`x2`, d => scaleLinear(d.x))

    mutationChartCircles
      .attr(`cx`, d => scaleLinear(d.x))

    animateScaleY({
      d3,
      d3Root,
      data,
      consequenceFilters,
      impactFilters,
      min,
      max,
      mutationChartLines,
      mutationChartCircles,
      height,
      xAxisOffset,
      visibleMutations: null,
      yTicks,
      yTicksLine,
    })

    if (!hideStats) {
      updateStats({
        d3,
        d3Root,
        store,
        data,
        consequences,
        impacts,
        consequenceColors,
        mutationChartLines,
        mutationChartCircles,
        height,
        xAxisOffset,
        consequencesCheckboxContainers,
        impactsCheckboxContainers,
        mutationCount,
        yTicks,
        yTicksLine,
      })
    }

    if (store.getState().animating) window.requestAnimationFrame(draw)
  }

  return draw

}

type TAnimateScaleYArgs = {
  d3: Object,
  d3Root: Object,
  data: Object,
  consequenceFilters: Array<string>,
  impactFilters: Array<string>,
  min: number,
  max: number,
  mutationChartLines: Object,
  mutationChartCircles: Object,
  height: number,
  xAxisOffset: number,
  visibleMutations: ?Array<Object>,
  yTicks: Object,
  yTicksLine: Object,
}
type TAnimateScaleY = (args: TAnimateScaleYArgs) => void
let animateScaleY: TAnimateScaleY = ({
  d3,
  data,
  consequenceFilters,
  impactFilters,
  min,
  max,
  mutationChartLines,
  mutationChartCircles,
  height,
  xAxisOffset,
  visibleMutations: vm,
  yTicks,
  yTicksLine,
}) => {
  let visibleMutations = vm || data.mutations.filter(d =>
    (d.x > min && d.x < max) &&
    !consequenceFilters.includes(d.consequence) &&
    !impactFilters.includes(d.impact)
  )

  if (visibleMutations.length) {

    let maxDonors = Math.max(...visibleMutations.map(x => x.donors))

    let scaleLinearY = d3.scaleLinear()
      .domain([0, Math.round(maxDonors + 5)])
      .range([height - xAxisOffset, 0])

    mutationChartLines
      .attr(`y2`, d => scaleLinearY(d.donors))

    mutationChartCircles
      .attr(`cy`, d => scaleLinearY(d.donors))

    // Vertical ticks

    yTicks
      .attr(`y`, i => scaleLinearY(i) + 3)

    yTicksLine
      .attr(`y1`, i => scaleLinearY(i))
      .attr(`y2`, i => scaleLinearY(i))
  }
}

/*----------------------------------------------------------------------------*/

export default animator
export { animateScaleY }
